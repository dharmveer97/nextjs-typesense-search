import { setupServer } from 'msw/node';\nimport { rest } from 'msw';\n\n// Mock data\nconst mockProducts = [\n  {\n    id: '1',\n    name: 'Test Product 1',\n    title: 'Test Product 1',\n    description: 'A test product for testing',\n    category: 'Electronics',\n    price: 99.99,\n    rating: 4.5,\n    reviews_count: 100,\n    in_stock: true,\n    brand: 'TestBrand',\n    tags: ['test', 'product'],\n    created_at: Date.now(),\n    updated_at: Date.now(),\n  },\n  {\n    id: '2',\n    name: 'Test Product 2',\n    title: 'Test Product 2',\n    description: 'Another test product',\n    category: 'Books',\n    price: 19.99,\n    rating: 4.0,\n    reviews_count: 50,\n    in_stock: true,\n    brand: 'TestBrand',\n    tags: ['test', 'book'],\n    created_at: Date.now(),\n    updated_at: Date.now(),\n  },\n];\n\nconst mockSearchResponse = {\n  facet_counts: [\n    {\n      field_name: 'category',\n      counts: [\n        { value: 'Electronics', count: 1 },\n        { value: 'Books', count: 1 },\n      ],\n    },\n  ],\n  found: 2,\n  hits: mockProducts.map(product => ({\n    document: product,\n    highlights: [\n      {\n        field: 'name',\n        snippet: product.name,\n        matched_tokens: ['Test'],\n      },\n    ],\n    text_match: 0.8,\n  })),\n  out_of: 2,\n  page: 1,\n  request_params: {\n    collection_name: 'products',\n    per_page: 20,\n    q: 'test',\n  },\n  search_time_ms: 5,\n};\n\nconst mockHealthResponse = {\n  status: 'healthy',\n  timestamp: new Date().toISOString(),\n  response_time_ms: 1,\n  checks: {\n    typesense: 'ok',\n  },\n  version: '1.0.0',\n  environment: 'test',\n  features: {\n    vector_search: true,\n    semantic_search: true,\n    analytics: true,\n    voice_search: true,\n    personalization: true,\n  },\n};\n\nconst mockAutocompleteResponse = {\n  query: 'test',\n  suggestions: [\n    {\n      text: 'test product',\n      type: 'query',\n      score: 1.0,\n      collection: 'suggestions',\n    },\n    {\n      text: 'Test Product 1',\n      type: 'document',\n      score: 0.9,\n      collection: 'products',\n      document_id: '1',\n      document: {\n        id: '1',\n        title: 'Test Product 1',\n        category: 'Electronics',\n        price: 99.99,\n        rating: 4.5,\n      },\n    },\n  ],\n  total: 2,\n  search_time_ms: 3,\n  collections_searched: ['products'],\n  type: 'both',\n};\n\n// Define handlers\nconst handlers = [\n  // Health check\n  rest.get('/api/typesense/health', (req, res, ctx) => {\n    return res(ctx.status(200), ctx.json(mockHealthResponse));\n  }),\n\n  // Regular search\n  rest.post('/api/typesense/search', (req, res, ctx) => {\n    const { q, collection } = req.body;\n    \n    if (!q) {\n      return res(\n        ctx.status(400),\n        ctx.json({ error: 'Query parameter is required' })\n      );\n    }\n    \n    return res(ctx.status(200), ctx.json(mockSearchResponse));\n  }),\n\n  // Federated search\n  rest.post('/api/typesense/federated-search', (req, res, ctx) => {\n    const { queries } = req.body;\n    \n    if (!queries || !Array.isArray(queries)) {\n      return res(\n        ctx.status(400),\n        ctx.json({ error: 'Queries array is required' })\n      );\n    }\n    \n    return res(\n      ctx.status(200),\n      ctx.json({\n        results: queries.map(() => mockSearchResponse),\n        search_time_ms: 10,\n        search_id: 'fed_test_123',\n        total_collections: queries.length,\n        total_results: mockSearchResponse.found * queries.length,\n      })\n    );\n  }),\n\n  // Semantic search\n  rest.post('/api/typesense/semantic-search', (req, res, ctx) => {\n    const { query, collection, mode = 'semantic' } = req.body;\n    \n    if (!query || !collection) {\n      return res(\n        ctx.status(400),\n        ctx.json({ error: 'Query and collection are required' })\n      );\n    }\n    \n    return res(\n      ctx.status(200),\n      ctx.json({\n        ...mockSearchResponse,\n        search_metadata: {\n          mode,\n          search_time_ms: 15,\n          embedding_time_ms: 5,\n          search_id: 'sem_test_123',\n          query_processed: query,\n          collection,\n          has_embedding: mode === 'vector' || mode === 'hybrid',\n        },\n      })\n    );\n  }),\n\n  // Autocomplete\n  rest.get('/api/typesense/autocomplete', (req, res, ctx) => {\n    const q = req.url.searchParams.get('q');\n    \n    if (!q) {\n      return res(\n        ctx.status(400),\n        ctx.json({ error: 'Query parameter is required' })\n      );\n    }\n    \n    return res(ctx.status(200), ctx.json(mockAutocompleteResponse));\n  }),\n\n  // Analytics\n  rest.post('/api/typesense/analytics', (req, res, ctx) => {\n    const { type, name, data } = req.body;\n    \n    if (!type || !name) {\n      return res(\n        ctx.status(400),\n        ctx.json({ error: 'Type and name are required' })\n      );\n    }\n    \n    return res(\n      ctx.status(200),\n      ctx.json({\n        success: true,\n        event_id: `${type}_test_123`,\n        timestamp: Date.now(),\n      })\n    );\n  }),\n\n  rest.get('/api/typesense/analytics', (req, res, ctx) => {\n    return res(\n      ctx.status(200),\n      ctx.json({\n        total_events: 100,\n        events: [\n          {\n            id: '1',\n            query: 'test',\n            collection: 'products',\n            timestamp: Date.now(),\n            response_time_ms: 5,\n            result_count: 2,\n          },\n        ],\n        facet_counts: [],\n        aggregations: {},\n      })\n    );\n  }),\n\n  // Geo search\n  rest.post('/api/typesense/geo-search', (req, res, ctx) => {\n    const { q, collection, lat, lng, radius_km } = req.body;\n    \n    if (!q || !collection || lat === undefined || lng === undefined) {\n      return res(\n        ctx.status(400),\n        ctx.json({ error: 'Query, collection, lat, and lng are required' })\n      );\n    }\n    \n    return res(\n      ctx.status(200),\n      ctx.json({\n        ...mockSearchResponse,\n        hits: mockSearchResponse.hits.map(hit => ({\n          ...hit,\n          geo_metadata: {\n            distance_km: 2.5,\n            within_radius: true,\n            search_center: { lat, lng },\n            search_radius_km: radius_km,\n          },\n        })),\n        geo_search_metadata: {\n          search_center: { lat, lng },\n          search_location_name: 'Test Location',\n          radius_km,\n          search_time_ms: 8,\n          total_within_radius: 2,\n          search_id: 'geo_test_123',\n        },\n      })\n    );\n  }),\n\n  // Collections management\n  rest.get('/api/typesense/collections', (req, res, ctx) => {\n    return res(\n      ctx.status(200),\n      ctx.json([\n        {\n          name: 'products',\n          num_documents: 1000,\n          fields: [\n            { name: 'id', type: 'string' },\n            { name: 'name', type: 'string' },\n            { name: 'description', type: 'string' },\n            { name: 'category', type: 'string', facet: true },\n            { name: 'price', type: 'float', facet: true },\n          ],\n          default_sorting_field: 'rating',\n        },\n        {\n          name: 'courses',\n          num_documents: 500,\n          fields: [\n            { name: 'id', type: 'string' },\n            { name: 'title', type: 'string' },\n            { name: 'description', type: 'string' },\n            { name: 'instructor', type: 'string' },\n            { name: 'difficulty', type: 'string', facet: true },\n          ],\n          default_sorting_field: 'rating',\n        },\n      ])\n    );\n  }),\n\n  // Documents CRUD\n  rest.post('/api/typesense/documents', (req, res, ctx) => {\n    const { collection, document } = req.body;\n    \n    if (!collection || !document) {\n      return res(\n        ctx.status(400),\n        ctx.json({ error: 'Collection and document are required' })\n      );\n    }\n    \n    return res(\n      ctx.status(201),\n      ctx.json({\n        ...document,\n        id: document.id || 'generated_id_123',\n      })\n    );\n  }),\n\n  rest.put('/api/typesense/documents/:id', (req, res, ctx) => {\n    const { id } = req.params;\n    const { collection, document } = req.body;\n    \n    return res(\n      ctx.status(200),\n      ctx.json({\n        ...document,\n        id,\n      })\n    );\n  }),\n\n  rest.delete('/api/typesense/documents/:id', (req, res, ctx) => {\n    return res(\n      ctx.status(200),\n      ctx.json({ success: true })\n    );\n  }),\n\n  // External API mocks (OpenAI, etc.)\n  rest.post('https://api.openai.com/v1/embeddings', (req, res, ctx) => {\n    return res(\n      ctx.status(200),\n      ctx.json({\n        data: [\n          {\n            embedding: new Array(1536).fill(0).map(() => Math.random() * 2 - 1),\n            index: 0,\n          },\n        ],\n        model: 'text-embedding-3-small',\n        usage: {\n          prompt_tokens: 10,\n          total_tokens: 10,\n        },\n      })\n    );\n  }),\n\n  // Catch all for unhandled requests\n  rest.all('*', (req, res, ctx) => {\n    console.error(`Unhandled request: ${req.method} ${req.url}`);\n    return res(\n      ctx.status(404),\n      ctx.json({ error: `Unhandled request: ${req.method} ${req.url}` })\n    );\n  }),\n];\n\n// Setup server\nexport const server = setupServer(...handlers);"