'use client';\n\nimport { useState, useCallback, useRef } from 'react';\nimport { useQuery } from '@tanstack/react-query';\nimport { useDebounce } from 'use-debounce';\nimport type { SearchResponse, SearchParams, MultiSearchResponse } from '../types/typesense';\n\nexport interface SearchState {\n  query: string;\n  collections: string[];\n  filters: Record<string, string[]>;\n  sortBy: string;\n  page: number;\n  perPage: number;\n  mode: 'normal' | 'semantic' | 'vector' | 'federated';\n  location?: {\n    lat: number;\n    lng: number;\n    radius: number;\n  };\n  userId?: string;\n  sessionId?: string;\n}\n\nexport interface SearchOptions {\n  enableAutoSearch?: boolean;\n  debounceMs?: number;\n  staleTime?: number;\n  cacheTime?: number;\n  enablePersistence?: boolean;\n  trackAnalytics?: boolean;\n}\n\nexport interface UseAdvancedSearchReturn {\n  // State\n  searchState: SearchState;\n  results: SearchResponse | MultiSearchResponse | null;\n  loading: boolean;\n  error: string | null;\n  \n  // Actions\n  search: (params?: Partial<SearchState>) => Promise<void>;\n  updateSearchState: (updates: Partial<SearchState>) => void;\n  clearSearch: () => void;\n  \n  // Utilities\n  searchTime: number;\n  totalResults: number;\n  totalPages: number;\n  hasNextPage: boolean;\n  hasPrevPage: boolean;\n  \n  // History\n  searchHistory: string[];\n  addToHistory: (query: string) => void;\n  clearHistory: () => void;\n}\n\nconst DEFAULT_SEARCH_STATE: SearchState = {\n  query: '',\n  collections: ['products', 'courses', 'documents'],\n  filters: {},\n  sortBy: '_text_match:desc',\n  page: 1,\n  perPage: 20,\n  mode: 'normal',\n};\n\nconst DEFAULT_OPTIONS: SearchOptions = {\n  enableAutoSearch: false,\n  debounceMs: 300,\n  staleTime: 5 * 60 * 1000, // 5 minutes\n  cacheTime: 10 * 60 * 1000, // 10 minutes\n  enablePersistence: true,\n  trackAnalytics: true,\n};\n\n// Analytics tracking helper\nasync function trackSearchEvent(\n  type: 'search' | 'click' | 'conversion',\n  data: any,\n  enabled: boolean = true\n) {\n  if (!enabled) return;\n  \n  try {\n    await fetch('/api/typesense/analytics', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        type,\n        name: `search_${type}`,\n        data,\n        timestamp: Date.now(),\n      }),\n    });\n  } catch (error) {\n    console.warn('Failed to track analytics:', error);\n  }\n}\n\nexport function useAdvancedSearch(\n  initialState: Partial<SearchState> = {},\n  options: Partial<SearchOptions> = {}\n): UseAdvancedSearchReturn {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n  const [searchState, setSearchState] = useState<SearchState>(() => {\n    // Load persisted state if enabled\n    if (opts.enablePersistence && typeof window !== 'undefined') {\n      const stored = localStorage.getItem('advancedSearchState');\n      if (stored) {\n        try {\n          const parsed = JSON.parse(stored);\n          return { ...DEFAULT_SEARCH_STATE, ...parsed, ...initialState };\n        } catch (e) {\n          console.warn('Failed to parse stored search state');\n        }\n      }\n    }\n    return { ...DEFAULT_SEARCH_STATE, ...initialState };\n  });\n  \n  const [searchHistory, setSearchHistory] = useState<string[]>(() => {\n    if (typeof window !== 'undefined') {\n      const stored = localStorage.getItem('searchHistory');\n      return stored ? JSON.parse(stored) : [];\n    }\n    return [];\n  });\n  \n  const [searchTime, setSearchTime] = useState(0);\n  const searchStartTime = useRef<number>(0);\n  \n  // Debounce query for auto-search\n  const [debouncedQuery] = useDebounce(\n    searchState.query,\n    opts.debounceMs\n  );\n  \n  // Create query key for React Query\n  const createQueryKey = useCallback((state: SearchState) => [\n    'advanced-search',\n    state.mode,\n    state.collections.join(','),\n    state.query,\n    state.filters,\n    state.sortBy,\n    state.page,\n    state.perPage,\n    state.location,\n  ], []);\n  \n  // Search function\n  const performSearch = useCallback(async (state: SearchState) => {\n    if (!state.query.trim() && state.mode !== 'federated') {\n      return null;\n    }\n    \n    searchStartTime.current = Date.now();\n    \n    try {\n      let response: Response;\n      let endpoint: string;\n      let body: any;\n      \n      switch (state.mode) {\n        case 'semantic':\n        case 'vector':\n          endpoint = '/api/typesense/semantic-search';\n          body = {\n            query: state.query,\n            collection: state.collections[0], // Semantic search on single collection\n            mode: state.mode,\n            query_by: 'title,description,content',\n            filter_by: buildFilterString(state.filters),\n            sort_by: state.sortBy,\n            facet_by: 'category,subcategory,brand,difficulty,type,status',\n            per_page: state.perPage,\n            page: state.page,\n            user_id: state.userId,\n          };\n          break;\n          \n        case 'federated':\n          endpoint = '/api/typesense/federated-search';\n          body = {\n            queries: state.collections.map(collection => ({\n              collection,\n              q: state.query || '*',\n              query_by: 'title,description,content',\n              filter_by: buildFilterString(state.filters),\n              sort_by: state.sortBy,\n              facet_by: 'category,subcategory,brand,difficulty,type,status',\n              per_page: Math.ceil(state.perPage / state.collections.length),\n              page: state.page,\n            })),\n            user_id: state.userId,\n            session_id: state.sessionId,\n          };\n          break;\n          \n        case 'normal':\n        default:\n          if (state.location) {\n            endpoint = '/api/typesense/geo-search';\n            body = {\n              q: state.query,\n              collection: state.collections[0], // Geo search on single collection\n              lat: state.location.lat,\n              lng: state.location.lng,\n              radius_km: state.location.radius,\n              query_by: 'title,description',\n              filter_by: buildFilterString(state.filters),\n              sort_by: state.sortBy,\n              facet_by: 'category,subcategory,brand',\n              per_page: state.perPage,\n              page: state.page,\n              user_id: state.userId,\n            };\n          } else {\n            // Regular search on first collection or federated if multiple\n            if (state.collections.length === 1) {\n              endpoint = '/api/typesense/search';\n              body = {\n                q: state.query,\n                collection: state.collections[0],\n                query_by: 'title,description,content',\n                filter_by: buildFilterString(state.filters),\n                sort_by: state.sortBy,\n                facet_by: 'category,subcategory,brand,difficulty,type,status',\n                per_page: state.perPage,\n                page: state.page,\n                user_id: state.userId,\n              };\n            } else {\n              // Multiple collections - use federated search\n              endpoint = '/api/typesense/federated-search';\n              body = {\n                queries: state.collections.map(collection => ({\n                  collection,\n                  q: state.query,\n                  query_by: 'title,description,content',\n                  filter_by: buildFilterString(state.filters),\n                  sort_by: state.sortBy,\n                  facet_by: 'category,subcategory,brand,difficulty,type,status',\n                  per_page: Math.ceil(state.perPage / state.collections.length),\n                  page: state.page,\n                })),\n                user_id: state.userId,\n                session_id: state.sessionId,\n              };\n            }\n          }\n          break;\n      }\n      \n      response = await fetch(endpoint, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(body),\n      });\n      \n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(errorData.message || `HTTP ${response.status}`);\n      }\n      \n      const data = await response.json();\n      \n      // Track analytics\n      if (opts.trackAnalytics) {\n        const searchData = {\n          q: state.query,\n          collections: state.collections,\n          search_time_ms: Date.now() - searchStartTime.current,\n          result_count: data.found || data.total_results || 0,\n          user_id: state.userId,\n          session_id: state.sessionId,\n          mode: state.mode,\n          filters: state.filters,\n          sort_by: state.sortBy,\n          page: state.page,\n        };\n        \n        trackSearchEvent('search', searchData, opts.trackAnalytics);\n      }\n      \n      return data;\n    } catch (error) {\n      console.error('Search error:', error);\n      throw error;\n    }\n  }, [opts.trackAnalytics]);\n  \n  // React Query for search results\n  const {\n    data: results,\n    isLoading: loading,\n    error: queryError,\n    refetch,\n  } = useQuery({\n    queryKey: createQueryKey(searchState),\n    queryFn: () => performSearch(searchState),\n    enabled: !!searchState.query.trim() || searchState.mode === 'federated',\n    staleTime: opts.staleTime,\n    gcTime: opts.cacheTime,\n    refetchOnWindowFocus: false,\n    retry: 1,\n  });\n  \n  // Auto-search with debounced query\n  const autoSearchQuery = useQuery({\n    queryKey: ['auto-search', debouncedQuery, ...createQueryKey(searchState).slice(2)],\n    queryFn: () => performSearch({ ...searchState, query: debouncedQuery }),\n    enabled: opts.enableAutoSearch && !!debouncedQuery.trim() && debouncedQuery !== searchState.query,\n    staleTime: opts.staleTime,\n    gcTime: opts.cacheTime,\n  });\n  \n  // Update search time when results change\n  useState(() => {\n    if (results && searchStartTime.current) {\n      setSearchTime(Date.now() - searchStartTime.current);\n    }\n  });\n  \n  // Persist state changes\n  const updateSearchState = useCallback((updates: Partial<SearchState>) => {\n    setSearchState(prev => {\n      const newState = { ...prev, ...updates };\n      \n      // Reset page when changing filters, sort, or query\n      if (updates.filters || updates.sortBy || updates.query !== undefined) {\n        newState.page = 1;\n      }\n      \n      // Persist to localStorage\n      if (opts.enablePersistence && typeof window !== 'undefined') {\n        localStorage.setItem('advancedSearchState', JSON.stringify(newState));\n      }\n      \n      return newState;\n    });\n  }, [opts.enablePersistence]);\n  \n  // Search action\n  const search = useCallback(async (params: Partial<SearchState> = {}) => {\n    updateSearchState(params);\n    await refetch();\n  }, [refetch, updateSearchState]);\n  \n  // Clear search\n  const clearSearch = useCallback(() => {\n    setSearchState(DEFAULT_SEARCH_STATE);\n    if (opts.enablePersistence && typeof window !== 'undefined') {\n      localStorage.removeItem('advancedSearchState');\n    }\n  }, [opts.enablePersistence]);\n  \n  // Search history management\n  const addToHistory = useCallback((query: string) => {\n    if (!query.trim()) return;\n    \n    setSearchHistory(prev => {\n      const updated = [query, ...prev.filter(q => q !== query)].slice(0, 20);\n      if (typeof window !== 'undefined') {\n        localStorage.setItem('searchHistory', JSON.stringify(updated));\n      }\n      return updated;\n    });\n  }, []);\n  \n  const clearHistory = useCallback(() => {\n    setSearchHistory([]);\n    if (typeof window !== 'undefined') {\n      localStorage.removeItem('searchHistory');\n    }\n  }, []);\n  \n  // Computed values\n  const totalResults = results?.found || results?.total_results || 0;\n  const totalPages = Math.ceil(totalResults / searchState.perPage);\n  const hasNextPage = searchState.page < totalPages;\n  const hasPrevPage = searchState.page > 1;\n  \n  const error = queryError ? String(queryError) : null;\n  \n  return {\n    // State\n    searchState,\n    results: (opts.enableAutoSearch && autoSearchQuery.data) || results || null,\n    loading: loading || autoSearchQuery.isLoading,\n    error,\n    \n    // Actions\n    search,\n    updateSearchState,\n    clearSearch,\n    \n    // Utilities\n    searchTime,\n    totalResults,\n    totalPages,\n    hasNextPage,\n    hasPrevPage,\n    \n    // History\n    searchHistory,\n    addToHistory,\n    clearHistory,\n  };\n}\n\n// Helper function to build filter strings\nfunction buildFilterString(filters: Record<string, string[]>): string {\n  const filterParts = Object.entries(filters)\n    .filter(([_, values]) => values.length > 0)\n    .map(([field, values]) => {\n      if (values.length === 1) {\n        return `${field}:${values[0]}`;\n      }\n      return `${field}:[${values.join(', ')}]`;\n    });\n  \n  return filterParts.join(' && ');\n}\n\n// Export helper function for external use\nexport { buildFilterString };"